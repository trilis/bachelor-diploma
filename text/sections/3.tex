\documentclass[../diploma.tex]{subfiles}
\begin{document}\label{sec:3}

\subsection{Анализ проблемы}

Как уже было упомянуто в главе \ref{sec:1}, вывод одних неявных модулей может зависеть от вывода других неявных модулей. То есть, на некоторых примерах успешность вывода модулей зависит от порядка, в котором они будут обрабатываться. Эта работа уделяет особое внимание исследованию таких примеров.

Проиллюстрируем важность этой проблемы на достаточно простом коде, реализующего возможность смешения чисел типа \texttt{int} и \texttt{float} при сложении: например, \mintinline{ocaml}{1 + 1.1}. В рамках этой работы было обнаружено, что, несмотря на свою простоту, данный код не будет работать в решении для OCaml:

\begin{minted}{ocaml}
module type PLUS = sig
  type t and u and res
  val ( + ) : t -> u -> res
end;;

let ( + ) {P : PLUS} = P.( + );;

implicit module Int_Int = struct
  type t = int and u = int and res = int
  let ( + ) = ( + )
end;;

implicit module Float_Float = struct
  type t = float and u = float and res = float
  let ( + ) = ( +. )
end;;

implicit module Int_Float = struct
  type t = int and u = float and res = float
  let ( + ) l r = (float_of_int l) +. r
end;;

implicit module Float_Int = struct
  type t = float and u = int and res = float
  let ( + ) l r = l +. (float_of_int r)
end;;

print_float ((1 + 1.1) + 2.5);;
\end{minted}

В этом коде опеределяется перегрузка оператора \mintinline{ocaml}{+} для всех возможных комбинаций из \mintinline{ocaml}{int} и \mintinline{ocaml}{float}. Прототип неявных модулей для OCaml выдаст ошибку "неоднозначность" на последней строчке. Дело в том, что в решении для OCaml модули обрабатываются в следующем порядке: неявный аргумент в функции будет выведен до того, как будут выведены неявные аргументы в других аргументах этой функции. Так, в выражении \mintinline{ocaml}{(1 + 1.1) + 2.5} первым будет выведен неявный аргумент для второго плюса. Так как первый плюс ещё не обработан, тип выражения \mintinline{ocaml}{1 + 1.1} ещё не выведен, поэтому второй плюс имеет тип \mintinline{ocaml}{'a -> float -> float}. Такому типу соответствуют и \mintinline{ocaml}{Float_Float}, и \mintinline{ocaml}{Int_Float}. Если бы первый плюс обрабатывался первым, то оба неявных аргумента были бы корректно выведены.

Заметим, что проблема проявляется, даже если отказаться от требования уникальности и подставить любой из кандидатов: если в примере выше не угадать и подставить \mintinline{ocaml}{Int_Float}, а не \mintinline{ocaml}{Float_Float}, то после этого тайп-чекер выдаст ошибку. Можно было бы после такой неудачной вставки откатиться к неоднозначному выводу и выбрать другой модуль, то есть осуществить поиск с возвратом (backtracking), но легко сконструировать код, на котором такое решение будет иметь экспоненциальную сложность.

Более того, возможны случаи, когда неправильный порядок обработки приводит к бесконечному числу кандидатов. Рассмотрим логическое сложение из параграфа ???. (TODO)

Во многих языках с неявными аргументами и выводом типов эта проблема проявляется. Из рассмотренных аналогов решение этой проблемы было обнаружено только в классах типов для Coq \cite{coq_typeclasses}. Для этого авторы переиспользуют специфическую тактику \texttt{eauto}, то есть их решение трудно применимо вне контекста автоматических систем доказательств.

\subsection{Алгоритм}

TODO

\subsection{Выводы и результаты по главе}

TODO

\end{document}
