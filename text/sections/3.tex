\documentclass[../diploma.tex]{subfiles}
\begin{document}\label{sec:3}

\subsection{Анализ проблемы}

Как уже было упомянуто в главе \ref{sec:1}, вывод одних неявных модулей может зависеть от вывода других неявных модулей. То есть, на некоторых примерах успешность вывода модулей зависит от порядка, в котором они будут обрабатываться. Эта работа уделяет особое внимание исследованию таких примеров.

Проиллюстрируем важность этой проблемы на достаточно простом коде, который реализует возможность смешения чисел типа \texttt{int} и \texttt{float} при сложении: например, \mintinline{ocaml}{1 + 1.1}. В рамках этой работы было обнаружено, что, несмотря на свою простоту, данный код не будет работать в решении для OCaml:

\begin{minted}{ocaml}
module type PLUS = sig
  type t and u and res
  val ( + ) : t -> u -> res
end;;

let ( + ) {P : PLUS} = P.( + );;

implicit module Int_Int = struct
  type t = int and u = int and res = int
  let ( + ) = ( + )
end;;

implicit module Float_Float = struct
  type t = float and u = float and res = float
  let ( + ) = ( +. )
end;;

implicit module Int_Float = struct
  type t = int and u = float and res = float
  let ( + ) l r = (float_of_int l) +. r
end;;

implicit module Float_Int = struct
  type t = float and u = int and res = float
  let ( + ) l r = l +. (float_of_int r)
end;;

print_float ((1 + 1.1) + 2.5);;
\end{minted}

В этом коде опеределяется перегрузка оператора \mintinline{ocaml}{+} для всех возможных комбинаций из \mintinline{ocaml}{int} и \mintinline{ocaml}{float}. Прототип неявных модулей для OCaml выдаст ошибку "неоднозначность" на последней строчке. Дело в том, что в решении для OCaml модули обрабатываются в следующем порядке: неявный аргумент в функции будет выведен до того, как будут выведены неявные аргументы в других аргументах этой функции. Так, в выражении \mintinline{ocaml}{(1 + 1.1) + 2.5} первым будет выведен неявный аргумент для второго плюса. Так как первый плюс ещё не обработан, тип выражения \mintinline{ocaml}{1 + 1.1} ещё не выведен, поэтому второй плюс имеет тип \mintinline{ocaml}{α -> float -> float}. Такому типу соответствуют и \mintinline{ocaml}{Float_Float}, и \mintinline{ocaml}{Int_Float}. Если бы первый плюс обрабатывался первым, то оба неявных аргумента были бы корректно выведены.

(TODO рассказать что если там вывод типов то всё совсем плохо, типа (1.1 + x) + (sqrt x))

Заметим, что проблема проявляется, даже если отказаться от требования уникальности и подставить любой из кандидатов: если в примере выше не угадать и подставить \mintinline{ocaml}{Int_Float}, а не \mintinline{ocaml}{Float_Float}, то после этого тайп-чекер выдаст ошибку. Можно было бы после такой неудачной вставки откатиться к неоднозначному выводу и выбрать другой модуль, то есть осуществить поиск с возвратом (backtracking), но легко построить пример, на котором такое решение будет иметь экспоненциальную сложность.

Более того, возможны случаи, когда неправильный порядок обработки приводит к бесконечному числу кандидатов. Рассмотрим логическое сложение из параграфа ???. (TODO)

Во многих языках с неявными аргументами и выводом типов эта проблема проявляется. Из рассмотренных аналогов решение этой проблемы было обнаружено только в классах типов для Coq \cite{coq_typeclasses}. Для этого авторы переиспользуют специфическую тактику \texttt{eauto}, то есть их решение трудно применимо вне контекста автоматических систем доказательств.

\subsection{Алгоритм}

(TODO Вводные)

Опишем сначала упрощённую версию алгоритма. Будем запускать поиск для различных неявных переменных, пока не найдётся переменная, для которой поиск успешно завершится. Успешно завершённый поиск может дать новую информацию посредством конкретизации некоторых переменных вывода типа, поэтому снова будем запускать поиск для оставшихся неявных переменных. В конце либо все неявные переменные разрешены, либо ни одна из оставшихся неявных переменных не может быть однозначно выведена. Если существует некоторый порядок, позволяющий вывести все неявные переменные, то такой алгоритм найдёт его. Таким образом, мы решили задачу, однако крайне неэффективно, поэтому опишем несколько оптимизаций.

Ниже будут определены три приоритета. На каждом шаге алгоритма будем пробовать обработать неявную переменную с высшим приоритетом из всех оставшихся.

\begin{enumerate}
\item Высший приоритет присваивается тем неявным переменным, которые зависят только от переменных вывода типов, не встречающихся в типах других неявных переменных (в частности, высшим приоритетом обладают неявные переменные с полностью выведенным типом). Если такая "уникальная" неявная переменная появилась, нужно обработать её в первую очередь, ведь если их обработка завершилась с ошибкой, можно не надеяться на новую информацию от других неявных переменных, а следует завершить весь алгоритм.

\item Второй приоритет присваивается неявным переменным, которые не были обработаны ни разу.

\item Третий приоритет~--- неявным переменным, которые уже были безуспешно обработаны до этого, но с момента последней обработки которых некоторые переменные вывода типов, содержащиеся в типе этих неявных переменных, были выведены.
\end{enumerate}

В отличие от наивного квадратичного алгоритма, алгоритм с такими оптимизациями будет сначала обрабатывать (за оптимальное, линейное время) те неявные переменные, между которыми нет сложных зависимостей. То есть применение такого алгоритма строго лучше имеющегося в OCaml: тогда как решение, предложенное в этой работе, не замедлится на случаях, которые можно обрабатывать в любом порядке, оно позволяет дополнительно поддержать все случаи, работающие только при определённом порядке обработки.

(TODO Сложность) 

(TODO Эвристики)

Алгоритм можно ещё больше оптимизировать с помощью мемоизации, сохраняя некоторые результаты неудачного поиска. Например, можно сохранять информацию о ветках, в которых не найдено ни одного кандидата (в последующих запусках в эти ветки можно не заходить) или частичную информацию о переменных вывода типов (если стало известно, что какое-то подмножество переменных вывода типов принимает одинаковое значения для всех возможных кандидатов, то можно унифицировать эти переменные даже в случае безуспешного поиска). В данной работе были реализованы только самые примитивные из подобных техник, но подробное исследование мемоизации для данной задачи является интересным направлением дальнейшей работы.

\subsection{Выводы и результаты по главе}

TODO

\end{document}
