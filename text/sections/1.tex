\documentclass[../diploma.tex]{subfiles}
\begin{document}\label{sec:1}

\subsection{Описание синтаксиса и семантики}

Для начала опишем, какие новые конструкции языка вносит в 1ML данная работа. Чтобы задать функцию с неявным параметром, неявный параметр нужно обернуть в квадратные скобки и явно протипизировать:

\begin{minted}{ocaml}
type SHOW = {
    type t
    show : t -> text
}

show [S: SHOW] x = S.show x
show_fun = fun [S : SHOW] x => S.show x
\end{minted}

Неявный модуль будет строиться, используя доступные в области видимости переменные, объявленные неявными с помощью ключевого слова \texttt{implicit}. Множество таких переменных будем в дальнейшем называть \textit{неявной областью видимости}.

\begin{minted}{ocaml}
implicit Show_int = {
    type t = int
    show = primitive "Int.toText"
}
\end{minted}

Заметим, что при объявлении модуля \texttt{Show\_int} не требуется явно указывать, что он удовлетворяет интерфейсу \texttt{SHOW}, как бы это, например, понадобилось в Scala или Haskell. Такое возможно из-за того, что в языках семейства ML используется структурная подтипизация.

Ключевым словом \texttt{implicit} можно аннотировать любое объявление переменной. В том числе, можно уже объявленный модуль внести в неявную область видимости следующим кодом:

\begin{minted}{ocaml}
Bool_to_string = {
    type t = bool
    show x = if x then "true" else "false"
}

implicit Show_bool = Bool_to_string
\end{minted}

Тем же ключевым словом \texttt{implicit} помечаются \textit{неявные функторы}:

(TODO подробнее определить?)

\begin{minted}{ocaml}
implicit Show_list [S: SHOW] = {
    type t = list S.t
    show x = "[" ++ (toText S.show x) ++ "]"
}
\end{minted}

Применение функции \texttt{show} возможно двумя способами: с явным указанием модуля и с неявным. В первом случае желаемый модуль оборачивается в квадратные скобки, во втором не указывается вовсе. Ниже будем называть вызов функции с пропущенными неявными аргументами \textit{неявной аппликацией}. Следующие два вызова будут семантически эквивалентны:

\begin{minted}{ocaml}
show [Show_int] 5
show 5
\end{minted}

А если вызвать функцию \texttt{show}, передав ей список чисел, то подставится \\ \texttt{Show\_list [Show\_int]}, то есть следующие два вызова эквивалентны:

\begin{minted}{ocaml}
show [Show_list [Show_int]] (1 :: (2 :: (3 :: nil)))
show (1 :: (2 :: (3 :: nil)))
\end{minted}

Локальные переменные могут быть также объявлены в качестве неявных:

\begin{minted}{ocaml}
let implicit Show_int = {
    type t = int
    show = primitive "Int.toText"
} in let implicit Show_list [S: SHOW] = {
    type t = list S.t
    show x = "[" ++ (toText S.show x) ++ "]"
} in show (1 :: (2 :: (3 :: nil)))
\end{minted}

Синтаксис в данной работе довольно близко следует за синтаксисом из \cite{white}, это сделано намеренно~--- с целью упростить сравнение мощности решений. Единственное существенное синтаксическое различие заключается в добавлении в этой работе синтаксической формы \texttt{[\_]}. Её можно использовать, чтобы явно указать место, где должен быть вставлен неявный модуль:

\begin{minted}{ocaml}
show [_] 5
\end{minted}

Мотивация для добавления этой конструкции будет описана в параграфе ???.

\subsection{Общая схема алгоритма}

Вывод неявных модулей производится на основе типов, которые эти модули должны иметь. То есть, чтобы определить, какой модуль необходимо неявно вывести, требуется вначале определить тип этого модуля. 

Рассмотрим, как выглядят такие типы, для примера снова возьмём функцию \texttt{show}. Напомним её определение:

\begin{minted}{ocaml}
show [S: SHOW] x = S.show x
\end{minted}

И протипизируем её:

\begin{minted}[escapeinside=||]{ocaml}
show : [S : SHOW] -> S.t -> text
\end{minted}

Применение такой функции, например, к переменной типа \texttt{int} инстанциирует \\\texttt{S.t = int}, то есть модуль будет искаться по типу \texttt{SHOW with t = int}, что уже (при условии, что есть только одно строковое представление для \texttt{int}) однозначно определяет модуль.

Не всегда тип неявного модуля известен заранее, так как он может зависеть от ещё невыведенных типов. Рассмотрим, например, такую функцию:

\begin{minted}{ocaml}
f x = Text.print (show x); x + 5
\end{minted}

Изначально \texttt{x} типизируется как некоторая переменная вывода типов \texttt{α}. Если вывод неявного модуля будет запущен до обработки подвыражения \texttt{x + 5}, то поиск модуля будет производиться по типу \texttt{SHOW with t = α} и потерпит неудачу, ведь каждый модуль типа \texttt{SHOW} удовлетворяет такому типу. Если же подвыражение \texttt{x + 5} уже будет типизировано, то полученное уравнение \texttt{α = int} позволит однозначно вывести корректный модуль.

Данный пример демонстрирует, что вывод неявных модулей зависит от вывода типов. Верно и обратное. Например, пусть есть только одна реализация типа модулей \texttt{SINGLE}, имеющая тип \texttt{SINGLE with t = int}. Тогда поиск неявного модуля по типу \texttt{SINGLE with t = α} приведёт к унификации \texttt{α = int}.

Можно предположить, что, раз вывод неявных модулей зависит от вывода типов, который в свою очередь, зависит от вывода неявных модулей, то вывод одних неявных модулей может зависеть от вывода других неявных модулей. Это действительно так, и обсуждению проблем, связанных с этим, посвящена глава \ref{sec:3}.

Так как вывод неявных модулей и вывод типов взаимно зависимы, нельзя завершить одно раньше начала другого, необходимо выполнять эти процессы в одной фазе компилятора. В существующем компиляторе 1ML проверка типов, вывод типов и преобразование в Систему F\textsubscript{$\omega$} осуществляются одним проходом по синтаксическому дереву. Соответственно, вывод неявных типов будет добавлен к этому проходу.

Простым решением, которое и было реализовано в первую очередь, было бы выводить неявный модуль в момент обработки неявной аппликации. Но, как было проиллюстрированно рассуждениями выше, в этот момент некоторые типы могут быть ещё не выведены, и для вывода модуля не хватит информации. На практике такое решение оказалось почти бесполезным.

Чтобы выводить модули в момент, в который про их типы будет известно больше информации, будем откладывать вывод модулей и выводить несколько модулей за раз. Обрабатывая неявную аппликацию, вставим вместо модуля специальную \textit{неявную переменную} с уникальным именем. Значение этой переменной будет определено позднее. А вот её тип уже известен, правда, он может быть не полностью выведен, то есть зависеть от нескольких переменных вывода типов. Поэтому проверка типов останется корректной после добавления такой фиктивной переменной. 

После добавления неявной переменной продолжается типизация кода и его преобразование в Систему F\textsubscript{$\omega$}, в процессе чего некоторые из переменных вывода типов, связанных с типами неявных переменных, могут быть выведены. Затем в некоторый момент (точное место этого момента будет определёно ниже, в параграфе ???) запускается поиск модулей для накопившихся неявных переменных. В случае успеха неявные переменные заменяются на термы Системы F\textsubscript{$\omega$}, соответствующие найденным модулям, а их типы окончательно выводятся, если не были выведены до этого.

Перейдём теперь к описанию непосредственно поиска модулей по типу. Заметим, что при наличии в неявной области функторов, которые принимают в качестве аргументов другие модули, число модулей, которые могут быть подставлены, бесконечно. Поэтому решение, перебирающее всех возможных кандидатов и сравнивающее их тип с нужным, не будет завершаться.

В связи с этим будем выводить модуль рекурсивно, поддерживая множество ограничений на тип. TODO

В результате поиск модулей либо корректно завершается, возвращая нужный модуль, либо возвращает одну из трёх ошибок: "нужный модуль не найден", "неоднозначность" (то есть нашлось несколько подходящих кандидатов) или "поиск не завершается" (чему будет посвящён параграф ???).

\subsection{Выводы и результаты по главе}

TODO

\end{document}
