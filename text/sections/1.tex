\documentclass[../diploma.tex]{subfiles}
\begin{document}\label{sec:1}

\subsection{Новый синтаксис}

Для начала опишем, какие новые конструкции языка вносит в 1ML данная работа. 

\subsection{Общая схема работы}

Вывод неявных модулей производится на основе типов, которые эти модули должны иметь. То есть, чтобы определить, какой модуль необходимо неявно вывести, требуется вначале определить тип этого модуля. 

Рассмотрим, как выглядят такие типы, для примера снова возьмём функцию \texttt{show}. Напомним её определение:

\begin{minted}{ocaml}
show [S: SHOW] x = S.show x
\end{minted}

И протипизируем её:

\begin{minted}[escapeinside=||]{ocaml}
show : |$\forall$| x. [S : SHOW with t = x] -> x -> text
\end{minted}

Применение такой функции, например, к переменной типа \texttt{int} породит уравнение \texttt{x = int}, то есть модуль будет искаться по типу \texttt{SHOW with t = int}, что уже (при условии, что есть только одно строковое представление для \texttt{int}) однозначно определяет модуль.

Не всегда тип неявного модуля известен заранее, так как он может зависеть от ещё невыведенных типов. Рассмотрим, например, такую функцию:

\begin{minted}{ocaml}
f x = Text.print (show x); x + 5
\end{minted}

Изначально \texttt{x} типизируется как некоторая типовая переменная \texttt{α}. Если вывод неявного модуля будет запущен до обработки подвыражения \texttt{x + 5}, то поиск модуля будет производиться по типу \texttt{SHOW with t = α} и потерпит неудачу, ведь каждый модуль типа \texttt{SHOW} удовлетворяет такому типу. Если же подвыражение \texttt{x + 5} уже будет типизировано, то полученное уравнение \texttt{α = int} позволит однозначно вывести корректный модуль.

Данный пример демонстрирует, что вывод неявных модулей зависит от вывода типов. Верно и обратное. Например, пусть есть только одна реализация типа модулей \texttt{SINGLE}, имеющая тип \texttt{SINGLE with t = int}. Тогда поиск неявного модуля по типу \texttt{SINGLE with t = α} приведёт к унификации \texttt{α = int}.

Так как вывод неявных модулей и вывод типов взаимно зависимы, нельзя завершить одно раньше начала другого, необходимо выполнять эти процессы в одной фазе компилятора. 

\subsection{Выводы и результаты по главе}

TODO

\end{document}
