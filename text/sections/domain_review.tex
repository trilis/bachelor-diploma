\documentclass[../diploma.tex]{subfiles}
\begin{document} \label{sec:domain_review}

\subsection{Модули первого класса и 1ML}

Отсутствие первоклассных модулей порождает практические проблемы при попытке интеграции между основным и модульными слоями ML. Например, долгое время был невозможен динамический выбор модуля:
\begin{minted}{ocaml}
module Map = if maxElems < 100 then BinTreeMap else HashTableMap 
\end{minted}

С целью сделать модули первоклассными Руссо предложил дополнить основной язык явной упаковкой и распаковкой модулей (packaged modules) \cite{packaged}. Это предложение было расширено последующими работами и было реализовано во многих диалектах ML, включая OCaml \cite{packaged_ocaml}. Упаковка и распаковка модулей решает самые остро стоящие практические проблемы, например, позволяя во многих случаях динамически выбирать модуль. Вместе с тем, решение Руссо предполагает наличие множества избыточных типовых аннотаций и недостаточно выразительные типы для некоторых случаев. Рассмотрим, например, динамический выбор модуля в OCaml:
\begin{minted}{ocaml}
module Map = (val (if maxElems < 100 
                   then (module BinTreeMap : MAP)
                   else (module HashTableMap : MAP))) : MAP)
\end{minted}

Несмотря на то, что задача решена, этот код выглядит намного менее лаконично и естественно, чем код выше. Что же касается выразительности, приведём пример, ограничивающий использование полиформизма. Типизация полиморфной функции, использующая модули, вынуждена использовать полиморфизм основного языка, например, так:
\begin{minted}{ocaml}
(module S with type t = 'a) -> (module S with type t = 'a) -> 'a
\end{minted}

Тогда как с действительно первоклассными модулями можно было бы выразить этот тип следующим образом:
\begin{minted}{ocaml}
(X : S) -> (module S with type t = X.t) -> X.t
\end{minted}

Используя полиморфизм основного языка, попробуем типизировать стандартную функцию \texttt{return}, принимающую монаду как модуль:
\begin{minted}{ocaml}
return : (module MONAD with type 'a t = ?) -> 'a -> ?
\end{minted}

Так как основной язык не поддерживает полиморфизм высших кайндов, на место вопросов в сигнатуре выше ничего нельзя подставить. 

Таким образом, упаковка и распаковка модулей частично решает проблемы, стоящие перед языком модулей ML, но имеет существенные недостатки. С другой стороны, сложно предложить решение, полностью решающее эти проблемы без существенной переработки основ языка.

Ряд более поздних работ показал, что историческое разделение языка на основной и модульный слои не является обязательным. Так, Россберг и другие показали, что все конструкции ML, включая модули, выражаются в рамках Системы F\textsubscript{$\omega$} \cite{fing}. Эти исследования привели к созданию Россбергом экспериментального диалекта 1ML \cite{1ml}, в котором стёрты различия между слоями и поддерживаются модули первого класса в истинном смысле этого выражения. Так, практические проблемы, описанные выше, в 1ML решены. Для обеспечения разрешимости проверки и вывода типов, автор использует идею Харпера~--- Митчела \cite{harper_mitchell} разделения типов на \textit{малые типы} и \textit{большие типы}, накладывая на последние ряд ограничений, например, вывод типов распространяется только на малые типы.  

\subsection{Ad hoc полиморфизм}

Термин "ad hoc полиморфизм" был предложен Стрэчи в 60-х годах XX века \cite{strachey}. Стрэчи разделяет два вида полиморфизма: \textit{параметрический полиморфизм}, то есть определение функции для разных типов аргументов, на каждых из которых функция работает одинаково, и \textit{ad hoc полиморфизм}, в котором функция работает разным образом в зависимости от типов аргументов. Тогда как общепринятым методом для параметрического полиморфизма в функциональных языках стала система типов Хиндли~--- Милнера, долгое время не существовало подходящего метода для ad hoc полиморфизма.

Одной из классических работ, решающих эту проблему, стало добавление в язык Haskell \textit{классов типов} \cite{adhoc}, вдохновлённое идеями из объектно-ориентированной парадигмы. Авторы предложили расширение системы типов Хиндли~--- Милнера ad hoс полиморфизмом и алгоритм, преобразующий код с классами типов в код без них, в стандартную систему типов Хиндли~--- Милнера. Таким образом, два вида полиморфизма были объединены в единую систему. Рассмотрим классы типов на простом примере.

\begin{minted}{haskell}
class Show a where
  show :: a -> String

instance Show Int where
  show = showSignedInt

show_twice x = show x ++ show x
\end{minted}

В примере выше определён класс типов \texttt{Show}. Описание этого класса типов состоит из набора функций, в данном случае~--- единственной функции \texttt{show}. Чтобы тип входил в класс типов, для него должны быть определены все эти функции. Эти функции для конкретного типа определяются с помощью создания \textit{экземпляра} (instance) и в дальнейшем могут использоваться как обычные функции. Рассмотрим тип функции \texttt{show\_twice}:

\begin{minted}{haskell}
show_twice :: Show a => a -> string
\end{minted}

Эту типизацию следует трактовать следующим образом: функция \texttt{show\_twice} имеет тип \texttt{a -> string} для всех \texttt{a}, которые входят в класс типов \texttt{Show}. Важно отметить, что в Haskell используемые классы типов не нуждаются в явном указании, а выводятся из тела функции. Так, в приведённом примере компилятор самостоятельно вывел ограничение \texttt{Show a}, исходя из того, что в теле функции использована функция \texttt{show}.

Похожие на классы типов решения были предложены в ряде других языков, например, в Rust (типажи, traits) \cite{rust}. Решения из этой группы объединяет необходимость \textit{каноничности}~--- для каждого типа и класса типов может быть определено не более одного экземпляра. (TODO: orphan instances)

Представителем другой группы является Scala и реализованные в ней \textit{неявные аргументы}, также называемые \textit{имплициты} \cite{implicits}. В Scala не требуется каноничность и присутствует возможность явно передать экземпляр, если система типов не способна вывести его самостоятельно. С другой стороны, для каждой функции требуется явно указывать, какие имплициты в ней используются, тогда как в решениях, основанных на классах типов, эта информация была бы выведена автоматически.

\begin{minted}{scala}
trait Showable [T] { 
  def show (x: T): String
}

implicit object IntShowable extends Showable [Int] {
  def show (x: Int) = x.toString
}

def show[T](x : T)(implicit s: Showable [T]): String = {
  s.show(x)
}

show(7)(IntShowable)
show(7)
\end{minted}

Неявные параметры в разных формах часто встречаются в языках с зависимыми типами. Рассмотрим подробнее Coq, язык, по историческим причинам имеющий много общего с ML. (TODO)

Вайтом и другими было предложено ввести в OCaml \textit{неявные модули} \cite{white}, решение, вдохновлённое имплицитами из Scala. Именно на этом решении основывается данная работа. Так же как и в Scala и Coq, предложение Вайта требует явного указания используемых неявных параметров и не требует каноничности, позволяя в случае неоднозначности явно указывать необходимый параметр. 

\begin{minted}{ocaml}
module type Show = sig
  type t
  val show : t -> string
end

implicit module Show_int = struct
  type t = int
  let show x = string_of_int x
end

implicit module Show_list {S : Show} = struct
  type t = S.t list
  let show x = string_of_list S.show x
end

let show {S : Show} x = S.show x

show 5 (* show {Show_int} 5 *)
show [1;2;3] (* show {Show_list (Show_int)} [1;2;3] *)
\end{minted}

Как уже было упомянуто, проверка каноничности возможна не во всех языках. Модульная система ML позволяет скрывать экземпляры за абстракцией. Рассмотрим, например, следующий код на OCaml:

\begin{minted}{ocaml}
module type Show = sig
  type t
  val show : t -> string
end

module F (X : Show) = struct
  implicit module S = X
end

implicit module Show_int = struct
  type t = int
  let show = string_of_int
end

module M = struct
  type t = int
  let show _ = "An int"
end

module N = F(M)
\end{minted}

(TODO: пояснить пример)

Дрейером и другими были предложены модулярные классы типов \cite{ml_typeclasses}, попытка применить классы типов из Haskell в ML. Поскольку в классическом подходе к классам типов требуется каноничность, а в ML невозможно проверить, соблюдается ли она, авторы вводят ряд нежелательных ограничений:

\begin{itemize}
	\item неявные модули могут быть объявлены только на верхнем уровне;
	\item все модули на верхнем уровне должны быть явно типизированы;
	\item на верхнем уровне могут находиться только модули.
\end{itemize}

Эти ограничения только усиливают синтаксическое разделение между модульным и основным слоем, о котором шла речь выше, что особенно нежелательно в 1ML, языке, построенного с целью ослабить это разделение. Помимо этого, модулярные классы типов, в отличие от решения Вайта и других, не поддерживают неявные параметры высшего ранга и кайнда, а также классы типов с несколькими параметрами.

Также в нескольких работах были предложены неявные аргументы \cite{experiments} и классы типов \cite{schneider} для ML как независимая от модулей функциональность. Такие решения привносят значительную дубликацию конструкций (так как модульные типы естественно подходят под роль описания классов типов) и не поддерживают продвинутую функциональность, например, параметры высшего кайнда.

\subsection{Выводы и результаты по главе}

Решение Вайта и 

\end{document}