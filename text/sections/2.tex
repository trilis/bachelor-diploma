\documentclass[../diploma.tex]{subfiles}
\begin{document}\label{sec:2}

\subsection{Проверка завершаемости}

Легко заметить, что описанный алгоритм поиска модуля может не завершаться. Рассмотрим следующий модуль:

\begin{minted}{ocaml}
implicit Show_id [Delegate: SHOW] = {
    type t = Delegate.t
    show = Delegate.show
}
\end{minted}

В присутствии такого модуля любая попытка вывести модуль будет бесконечно строить модуль вида \mintinline{ocaml}{Show_id [Show_id [Show_id ...]]}. Чтобы гарантировать завершаемость алгоритма, применим классический метод. Будем проверять, что с момента последнего применения функтора, который алгоритм применяет в данный момент, была получена новая информация, то есть в данный момент решается более простая задача, чем решалась в предыдущий раз.

Понятие "задача стала проще" определим следующим образом: хотя бы одно ограничение на тип стало строго меньше, а остальные не увеличились. Под порядком "меньше" будем понимать простое структурное включение одного ограничения в другой. Ясно, что с таким ограничением поиск всегда будет завершаться.

Поясним эту идею на примере. (TODO)

Если было определено, что поиск может не завершаться, то следует вернуть ошибку, даже если в другой ветке поиска найден подходящий модуль, так как в таком случае нельзя гарантировать уникальность найденного модуля.

На самом деле, в некоторых случаях поиск может не завершаться, из-за того, что некоторые типы в ограничениях ещё не полностью выведены. При этом 

\subsection{Генерализация типов (???) переименовать}

TODO

\subsection{Локальные неявные модули}

TODO

\subsection{Синтаксис \texttt{[\_]}}

Объясним мотивацию, стоящую за введением синтаксической формы \texttt{[\_]}, означающей "в этом месте необходимо вывести модуль". Дело в том, что алгоритм определяет, что модуль необходимо вывести, если обнаруживает неявную аппликацию. Тем не менее, существуют неявные выражения, в которых аппликация вовсе отсутствует. Рассмотрим, например, следующий интерфейс, определяющий нейтральный элемент, и модуль, реализующий этот интерфейс для сложения чисел:

\begin{minted}{ocaml}
type NEUTRAL = {
    type t
    neutral: t
}

implicit NeutralAdd = {
    type t = int
    neutral = 0
}
\end{minted}

И определим неявную функцию, возвращающую нейтральный элемент:

\begin{minted}{ocaml}
neutral [N : NEUTRAL] = N.neutral
\end{minted}

Но как использовать эту функцию? Действительно, так как тип этой функции~--- \mintinline{ocaml}{[N : NEUTRAL] -> N.t}, то нет явных аргументов, к которым можно применить эту функцию, чтобы появилась неявная аппликация. Тем не менее, в некоторых контекстах этот модуль можно вывести, например, в выражении \mintinline{ocaml}{5 + neutral}. Такое выражение не будет компилироваться в решении для OCaml, но аналогичные конструкции поддержаны в других языках, например, в Scala. Единственный способ применить такую функцию в решении для OCaml~--- передать ей явный аргумент, \mintinline{ocaml}{5 + neutral [NeutralAdd]}.

Проблема заключается в том, что с такими функциями не всегда ясно, что имел в виду программист: обращение к функции как есть, или вызов её с выводом неявного параметра. Особенно эта двусмысленность видна в выражениях вида \mintinline{ocaml}{let x = neutral in ...} или в случае передачи функции \texttt{neutral} в качестве аргумента функции высшего порядка. 

В этой работе предлагается явное синтаксическое разделение двусмысленности семантики. В случае, если за неявной функцией, у которой нет явных аргументов, будет стоять токен \texttt{[\_]}, выражение будет трактоваться как неявная аппликация, и модуль будет выведен, в противном же случае функция будет трактоваться как есть. Это разумный компромисс: он позволяет не выписывать явно неявные модули для таких функций, ограничиваясь только явным указанием, что вывести нужно, при этом не усложняет ни тайп-чекер, ни читаемость кода.

\subsection{Неявные аргументы для функторов}

В решении для OCaml, тогда как модули могут использоваться в качестве неявных аргументов для \textit{функций}, использование модулей в качестве неявных аргументов для \textit{функторов} не поддерживается. Напомним, что в OCaml функции и функторы находятся на разных слоях языка, поэтому поддержка неявных аргументов для функторов в OCaml требует дополнительных теоретических исследований, и, вероятно, потребует дублирования функциональности. Так как в языке 1ML функции и функторы являются частными случаями одной и той же конструкции, можно минимальными усилиями переиспользовать наше решение, чтобы поддержать неявные аргументы для функторов.

Опишем несколько случаев, в которых эта функциональность может быть полезна. Допустим, были определены два модуля, отвечаюшие за строковое представление списков: \mintinline{ocaml}{Show_list1} и \mintinline{ocaml}{Show_list2}. Их сигнатура одинакова, поэтому при применении неявной функции \mintinline{ocaml}{show} требуется выбрать модуль явно. Без поддержки неявных аргументов это делается следующим кодом:

\begin{minted}{ocaml}
show [Show_list1 [Show_pair [Show_string] [Show_int]]]
     (("hello" , 1) :: (("world", 2) :: nil))
\end{minted}

Заметим, что неоднозначность проявляется только при выборе \mintinline{ocaml}{Show_list1}, а вот часть \mintinline{ocaml}{Show_pair [Show_string] [Show_int]} может быть выведена автоматически. Поддержка неявных аргументов для функторов позволяет так переписать этот вызов:

\begin{minted}{ocaml}
show [Show_list1 [_]] (("hello" , 1) :: (("world", 2) :: nil))
\end{minted}

Отметим, что в этом примере была использована синтаксическая форма \mintinline{ocaml}{[_]}, введённая в предыдущем параграфе. Тогда как необходимость в ней для неявных функций появляется достаточно редко, для функторов она требуется достаточно часто, так как у неявных функторов все аргументы неявные.

В примере выше неявные аргументы для функторов применены в комбинации с неявными аргументами для функций. Неявные аргументы для функторов могут быть использованы и сами по себе. Рассмотрим, например (TODO придумать пример (MAP?))

\subsection{Логическое программирование}

Фреймворк неявных модулей можно воспринимать как (достаточно неудобный и урезанный) способ создавать программы в логической парадигме. 

\subsection{Выводы и результаты по главе}

TODO

\end{document}
