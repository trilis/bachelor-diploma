\documentclass[../diploma.tex]{subfiles}
\begin{document}\label{sec:2}

\subsection{Проверка завершаемости}

Легко заметить, что описанный алгоритм поиска модуля может не завершаться. Рассмотрим следующий модуль:

\begin{minted}{ocaml}
implicit Show_id [Delegate: SHOW] = {
    type t = Delegate.t
    show = Delegate.show
}
\end{minted}

В присутствии такого модуля любая попытка вывести модуль будет бесконечно строить модуль вида \texttt{Show\_id [Show\_id [Show\_id ...]]}. Чтобы гарантировать завершаемость алгоритма, применим классический метод. TODO

\subsection{Генерализация типов}

TODO

\subsection{Локальные неявные модули}

TODO

\subsection{Синтаксис \texttt{[\_]}}

Объясним мотивацию, стоящую за введением синтаксической формы \texttt{[\_]}, означающей "в этом месте необходимо вывести модуль". Дело в том, что алгоритм определяет, что модуль необходимо вывести, если обнаруживает неявную аппликацию. Тем не менее, существуют неявные выражения, в которых аппликация вовсе отсутствует. Рассмотрим, например, следующий интерфейс, определяющий нейтральный элемент, и модуль, реализующий этот интерфейс для сложения чисел:

\begin{minted}{ocaml}
type NEUTRAL = {
    type t
    neutral: t
}

implicit NeutralAdd = {
    type t = int
    neutral = 0
}
\end{minted}

И определим неявную функцию, возвращающую нейтральный элемент:

\begin{minted}{ocaml}
neutral [N : NEUTRAL] = N.neutral
\end{minted}

Но как использовать эту функцию? Действительно, так как тип этой функции~--- \mintinline{ocaml}{[N : NEUTRAL] -> N.t}, то нет явных аргументов, к которым можно применить эту функцию, чтобы появилась неявная аппликация. Тем не менее, в некоторых контекстах этот модуль можно вывести, например, в выражении \mintinline{ocaml}{5 + neutral}. Такое выражение не будет компилироваться в решении для OCaml, но аналогичные конструкции поддержаны в других языках, например, в Scala. Единственный способ применить такую функцию в решении для OCaml~--- передать ей явный аргумент, \mintinline{ocaml}{5 + neutral [NeutralAdd]}.

Проблема заключается в том, что с такими функциями не всегда ясно, что имел в виду программист: обращение к функции как есть, или вызов её с выводом неявного параметра. Особенно эта двусмысленность видна в выражениях вида \mintinline{ocaml}{let x = neutral in ...} или в случае передачи функции \texttt{neutral} в качестве аргумента функции высшего порядка. 

В этой работе предлагается явное синтаксическое разделение двусмысленности семантики. В случае, если за неявной функцией, у которой нет явных аргументов, будет стоять токен \texttt{[\_]}, выражение будет трактоваться как неявная аппликация, и модуль будет выведен, в противном же случае функция будет трактоваться как есть. Это разумный компромисс: он позволяет не выписывать явно неявные модули для таких функций, ограничиваясь только явным указанием, что вывести нужно, при этом не усложняет ни тайп-чекер, ни читаемость кода.

\subsection{Неявные функторы}

TODO

\subsection{Выводы и результаты по главе}

TODO

\end{document}
